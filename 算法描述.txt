算法描述：

一、将整个词典的单词分组
	由于每次输入的两个单词长度一致（记为n）， 若它们存在变换词阶，变换词阶里的所有单词的长度也为n. 因此可以将整个词典里的单词，按照单词长度分组，对于长度为n的所有单词，建立一个单独的网络。
	
二、建立网络
	输入：长度为n的单词组
	输出：长度为n的单词组对应的网络
	
	考虑到变换词阶中，相邻单词只相差一个字母，并且两个单词都在词典中。
	如单词data是date的邻居。
	在将要建立的网络中，互为邻居的两个单词有一条边相邻。
	为了快速获取某个单词的邻居，使用这样的方法：
	
	边记录：
	edges[int 修改位编号][string 删掉修改位后的字符串] = [修改位的字符]
	如data有：
	edges[0]["ata"] = ['d',...]
	edges[1]["dta"] = ['a',...]
	edges[2]["dae"] = ['t',...]
	edges[3]["dat"] = ['a',...]
	若要获得单词data的邻居，则获取edges[0]["ata"], edges[1]["dta"], edges[2]["dae"], edges[3]["dat"]的值
	如edges[3]["dat"] = ['e', ...], 表示data存在邻居date.
	获取邻居的时间复杂度为：nlog(n)
	
	这样建立边记录，即可建成网络
	
三、网络搜索
	网络建立后，对于输入的两个单词，使用BFS（广度优先搜索）的方法查找两个单词是否连通。
	若两单词连通，需要输出它们的路径。
	因此在使用BFS时，记录某个单词的上一个节点。
	若找到目标节点，则根据记录从目标点走到出发点，得到完整路径。